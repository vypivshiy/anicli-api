# Python 3.8: generate TypedDict annotations + async & sync httpx clients

## Rules / Overview

- Generate **one file** containing:
  1. Imports
  2. Types (TypedDict, enums)
  3. Sync client: {info.title}Sync
  4. Async client: {info.title}Async
- Clients use **httpx**.
- All client methods return **APIResponse[T]** (Result-like monad).
- Async methods: `async def ...`
- Sync methods: `def ...`
- All method names should be identical between sync/async clients.

---

## Imports

- Explicitly include:
```python
# generated by LLM based from swagger configuration.
# There may be inaccuracies in the data types of the fields.
from typing import List, Optional, Union, Any, Dict, Tuple, Generic, TypeVar
from typing_extensions import NotRequired, Required, TypedDict, Literal, NamedTuple
import httpx
from pathlib import Path
import io
````

---

## Typing / Models

* **Objects**: use TypedDict, prefix `T_`

  ```python
  T_User = TypedDict("T_User", {"id": int, "name": str})
  ```
* **Nested objects**: reuse TypedDict types.
    
    ```python
  E_SocialType = Literal["vk", "google", "patreon", "discord"]
  T_Avatar = TypedDict("T_Avatar", {"image": str, "width": float, "height": float})
  # !!! ERROR not allowed pass nested types as string in TypedDict function !!!
  T_User = TypedDict("T_User", {"id": int, "name": str, "type": "E_SocialType", "avatar": "T_Avatar"})
  ```

  ```python
  E_SocialType = Literal["vk", "google", "patreon", "discord"]
  T_Avatar = TypedDict("T_Avatar", {"image": str, "width": float, "height": float})
  
  T_User = TypedDict("T_User", {"id": int, "name": str, "type": E_SocialType, "avatar": T_Avatar})
  ```

* **Enums**: use Literal, prefix `E_`

  ```python
  E_StatusStr = Literal["NEW", "ACTIVE", "CLOSED"]
  E_StatusInt = Literal[1, 2, 3]
  ```
* **Nullable / optional fields**: `Optional[T] = None`
* **Excluded optional fields**: use `NotRequired`
* **Nested types**: reuse defined TypedDict or List types
* **Required fields**: use `Required`
* **Lists**: `List[T]`, `List[T_ObjName]`
* **Files / multipart**: `str | Path | io.IOBase | bytes` (str = filename path)
* **Unknown types**: use `Any`
* **Primitive mapping**:

  * int32 / int64 → int
  * float32 / float64 → float
  * date-time / uuid → str

---

## APIResponse / Result-like Monad

```python
class APIResponse(NamedTuple, Generic[T]):
    """Monad-like response wrapper"""
    success: bool
    data: T
    status_code: int
    headers: Dict[str, str]
    error: Optional[Exception]  # populated if success=False AND raise_on_error=False

    def raise_for_status(self) -> None:
        if not self.success and self.error:
            raise self.error
```

* Client methods return `APIResponse[T]`
* If `raise_on_error=True`, exceptions are raised (ApiError)

---

## Client Templates

### Sync Client

```python
class {{info.title}}Sync:
    def __init__(self, base_url: str = "", *,
                 api_key: Optional[str] = None,
                 bearer_token: Optional[str] = None,
                 basic_auth: Optional[Tuple[str, str]] = None,
                 headers: Optional[Dict[str, str]] = None,
                 timeout: Optional[float] = None,
                 client: Optional[httpx.Client] = None,
                 raise_on_error: bool = False):
        self.base_url = base_url.rstrip("/")
        self._api_key = api_key
        self._bearer = bearer_token
        self._basic = basic_auth
        self._headers = headers or {}
        self._timeout = timeout
        self.raise_on_error = raise_on_error
        self._client = client or httpx.Client(timeout=self._timeout)

    # private method to reduce boilerplate
    def _request(self, method: str, path: str,
                 params: Optional[Dict[str, Any]] = None,
                 headers: Optional[Dict[str, str]] = None,
                 json: Optional[Any] = None,
                 files: Optional[Dict[str, Any]] = None,
                 data: Optional[Any] = None) -> APIResponse[Any]: ...
    
    # insert sync methods here
    # def get_users(...) -> APIResponse[T_User]: ...
```

### Async Client

```python
class {{info.title}}Async:
    def __init__(self, base_url: str = "", *,
                 api_key: Optional[str] = None,
                 bearer_token: Optional[str] = None,
                 basic_auth: Optional[Tuple[str, str]] = None,
                 headers: Optional[Dict[str, str]] = None,
                 timeout: Optional[float] = None,
                 client: Optional[httpx.AsyncClient] = None,
                 raise_on_error: bool = False):
        self.base_url = base_url.rstrip("/")
        self._api_key = api_key
        self._bearer = bearer_token
        self._basic = basic_auth
        self._headers = headers or {}
        self._timeout = timeout
        self.raise_on_error = raise_on_error
        self._client = client or httpx.AsyncClient(timeout=self._timeout)

    # private async request
    async def _request(self, method: str, path: str,
                       params: Optional[Dict[str, Any]] = None,
                       headers: Optional[Dict[str, str]] = None,
                       json: Optional[Any] = None,
                       files: Optional[Dict[str, Any]] = None,
                       data: Optional[Any] = None) -> APIResponse[Any]: ...
    
    # insert async methods here
    # async def get_users(...) -> APIResponse[T_User]: ...
```

---

## Documentation / Docstrings

* Use **Google-style docstrings**
* Include:

  * **Description / summary**: from OpenAPI, do not invent
  * **Arguments**: type + note if special (`date-time`, `uuid`, file)
  * **Returns**: `APIResponse[T]`
  * **Raises**: `ApiError` if raise_on_error=True
* Example argument annotation:

  ```python
  begin_date: str  # date-time
  files: List[Union[Path, str, bytes, io.BytesIO]]  # uploaded files
  ```

---

## Exceptions

* Define `ApiError(Exception)` for HTTP>=400 if `raise_on_error=True`.

---

## OpenAPI Schema

* Insert the OpenAPI v3 spec here or provide file: `{{ INSERT OPENAPI SCHEMA HERE }}`
* LLM should generate models and methods **only from provided spec**.

---

## Notes

* Ensure **Python 3.8 compatibility**:
  * No `list[int]`, use `List[int]`
  * No `str | None`, use `Optional[str]`
  * `from typing import NamedTuple`, **NOT `collections module`**
* `_request` method signatures must match sync / async conventions.
* TypedDict and enums must be declared **before client classes**.
* TypedDict as function API not allowed pass nested types as string
* TypedDict as call expression API not allowed pass directly in annotations
* Client methods must return `APIResponse[T]` consistently.
* in base_url: str = "{{servers.url}}" placeholder insert first default server with full url path from openapi spec


{{INSERT yaml/json openapi schema here or upload file}}