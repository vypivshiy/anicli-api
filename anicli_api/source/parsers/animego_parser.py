# autogenerated by ssc-gen DO NOT EDIT

from __future__ import annotations

import re
import sys
import json
from html import unescape as _html_unescape
from typing import TypedDict, Union
from contextlib import suppress
from functools import reduce

if sys.version_info >= (3, 10):
    from types import NoneType
    from typing import TypeAlias
else:
    NoneType = type(None)

    try:
        from typing_extensions import TypeAlias  # noqa
    except ImportError:
        msg = "python < 3.10 required 'typing_extensions' dependency"
        raise ImportError(msg)
from lxml import html


_RE_HEX_ENTITY = re.compile(r"&#x([0-9a-fA-F]+);")
_RE_UNICODE_ENTITY = re.compile(r"\\\\u([0-9a-fA-F]{4})")
_RE_BYTES_ENTITY = re.compile(r"\\\\x([0-9a-fA-F]{2})")
_RE_CHARS_MAP = {"\\b": "\b", "\\f": "\f", "\\n": "\n", "\\r": "\r", "\\t": "\t"}


def ssc_unescape(s: str) -> str:
    s = _html_unescape(s)
    s = _RE_HEX_ENTITY.sub(lambda m: chr(int(m.group(1), 16)), s)
    s = _RE_UNICODE_ENTITY.sub(lambda m: chr(int(m.group(1), 16)), s)
    s = _RE_BYTES_ENTITY.sub(lambda m: chr(int(m.group(1), 16)), s)
    for ch, r in _RE_CHARS_MAP.items():
        s = s.replace(ch, r)
    return s


def ssc_map_replace(s: str, replacements: dict[str, str]) -> str:
    return reduce(lambda acc, kv: acc.replace(kv[0], kv[1]), replacements.items(), s)


def ssc_rm_prefix(v: str, p: str) -> str:
    return v[len(p) :] if v.startswith(p) else v


def ssc_rm_suffix(v: str, s: str) -> str:
    return v[: -(len(s))] if v.endswith(s) else v


def ssc_rm_prefix_and_suffix(v: str, p: str, s: str) -> str:
    return ssc_rm_suffix(ssc_rm_prefix(v, p), s)


FALLBACK_HTML_STR = "<html><body></body></html>"
J_AggregateRating = TypedDict(
    "J_AggregateRating",
    {
        "type": str,
        "ratingCount": int,
        "bestRating": int,
        "ratingValue": str,
    },
)
J_Director = TypedDict(
    "J_Director",
    {
        "type": str,
        "url": str,
        "name": str,
    },
)
J_Actor = TypedDict(
    "J_Actor",
    {
        "type": str,
        "url": str,
        "name": str,
    },
)
J_Creator = TypedDict(
    "J_Creator",
    {
        "type": str,
        "name": str,
    },
)
J_Content = TypedDict(
    "J_Content",
    {
        "context": str,
        "type": str,
        "url": str,
        "name": str,
        "alternateName": str,
        "image": str,
        "description": str,
        "genre": list[str],
        "contentRating": str,
        "datePublished": str,
        "keywords": str,
        "creator": list[J_Creator],
        "aggregateRating": J_AggregateRating,
        "numberOfEpisodes": int,
    },
)
T_PageUtils = TypedDict(
    "T_PageUtils",
    {
        "url_canonical": str,
    },
)
T_PageOngoing = TypedDict(
    "T_PageOngoing",
    {
        "url_path": str,
        "title": str,
        "thumbnail": str,
        "episode": str,
        "dub": str,
    },
)
T_PageSearch = TypedDict(
    "T_PageSearch",
    {
        "title": str,
        "thumbnail": str,
        "url": str,
    },
)
T_PageAnime = TypedDict(
    "T_PageAnime",
    {
        "title": str,
        "description": str,
        "thumbnail": str,
        "id": str,
        "raw_json": J_Content,
    },
)
T_Episodes = TypedDict(
    "T_Episodes",
    {
        "num": int,
        "title": str,
        "type": str,
        "released": str,
        "id": str,
    },
)
T_Dubbers: TypeAlias = dict[str, str]
T_PageEpisode = TypedDict(
    "T_PageEpisode",
    {
        "is_film": bool,
        "episodes": list[T_Episodes],
        "dubbers": T_Dubbers,
    },
)
T_EpisodeVideos = TypedDict(
    "T_EpisodeVideos",
    {
        "player": str,
        "data_provider": str,
        "data_provide_dubbing": str,
    },
)
T_PageEpisodeVideo = TypedDict(
    "T_PageEpisodeVideo",
    {
        "is_film": bool,
        "dubbers": T_Dubbers,
        "videos": list[T_EpisodeVideos],
    },
)
T_SourceVideoView = TypedDict(
    "T_SourceVideoView",
    {
        "title": str,
        "url": str,
        "data_provider": str,
        "data_provide_dubbing": str,
        "data_translation_title": str,
    },
)
T_PageSource = TypedDict(
    "T_PageSource",
    {
        "dubbers": T_Dubbers,
        "videos": list[T_SourceVideoView],
    },
)


class PageUtils:
    """

    {
        "url_canonical": "String"
    }"""

    def __init__(self, document: Union[str, html.HtmlElement]) -> None:
        if isinstance(document, html.HtmlElement):
            self._document = document
        elif isinstance(document, str):
            self._document = html.fromstring(document.strip() or FALLBACK_HTML_STR)

    def _parse_url_canonical(self, v: html.HtmlElement) -> str:
        v0 = v.cssselect('link[rel="canonical"]')[0]
        v1 = v0.get("href")

        return v1.rstrip("/")

    def parse(self) -> T_PageUtils:
        return {
            "url_canonical": self._parse_url_canonical(self._document),
        }


class PageOngoing:
    """Get all available ongoings from the main page

    GET https://animego.one


    NOTE: animego can change the domain, so only the path is returned.
    To get the real url, extract the value using the selector 'link[rel="canonical"]::attr(href)'



    [
        {
            "url_path": "String",
            "title": "String",
            "thumbnail": "String",
            "episode": "String",
            "dub": "String"
        },
        "..."
    ]"""

    def __init__(self, document: Union[str, html.HtmlElement]) -> None:
        if isinstance(document, html.HtmlElement):
            self._document = document
        elif isinstance(document, str):
            self._document = html.fromstring(document.strip() or FALLBACK_HTML_STR)

    def _split_doc(self, v: html.HtmlElement) -> list[html.HtmlElement]:
        return v.cssselect(".updates-body > div.d-grid > a.aw-item")

    def _parse_url_path(self, v: html.HtmlElement) -> str:
        return v.get("href")

    def _parse_title(self, v: html.HtmlElement) -> str:
        v0 = v.cssselect(".image__img")[0]

        return v0.get("alt")

    def _parse_thumbnail(self, v: html.HtmlElement) -> str:
        v0 = v.cssselect(".image__img")[0]

        return v0.get("src")

    def _parse_episode(self, v: html.HtmlElement) -> str:
        v0 = v.cssselect(".aw-meta")[0]
        v1 = v0.text_content()

        return re.search("\\s(\\d+)\\s", v1)[1]

    def _parse_dub(self, v: html.HtmlElement) -> str:
        v0 = v.cssselect(".aw-meta")[0]
        v1 = v0.text_content()

        return re.search("(\\w+)\\s+—", v1)[1]

    def parse(self) -> list[T_PageOngoing]:
        return [
            {
                "url_path": self._parse_url_path(el),
                "title": self._parse_title(el),
                "thumbnail": self._parse_thumbnail(el),
                "episode": self._parse_episode(el),
                "dub": self._parse_dub(el),
            }
            for el in self._split_doc(self._document)
        ]


class PageSearch:
    """Get all search results by query

    USAGE:

        GET https://animego.one/search/anime
        q={QUERY}

    EXAMPLE:

        GET https://animego.one/search/anime?q=LAIN


    [
        {
            "title": "String",
            "thumbnail": "String",
            "url": "String"
        },
        "..."
    ]"""

    def __init__(self, document: Union[str, html.HtmlElement]) -> None:
        if isinstance(document, html.HtmlElement):
            self._document = document
        elif isinstance(document, str):
            self._document = html.fromstring(document.strip() or FALLBACK_HTML_STR)

    def _split_doc(self, v: html.HtmlElement) -> list[html.HtmlElement]:
        return v.cssselect(".grid.ani-list > .ani-grid__item")

    def _parse_title(self, v: html.HtmlElement) -> str:
        v0 = v.cssselect(".ani-grid__item-title a")[0]

        return v0.get("title")

    def _parse_thumbnail(self, v: html.HtmlElement) -> str:
        v0 = v.cssselect(".image__img")[0]

        return v0.get("src")

    def _parse_url(self, v: html.HtmlElement) -> str:
        v0 = v.cssselect("ani-grid__item-title a")[0]
        v1 = v0.get("href")

        return f"https://animego.me{v1}"

    def parse(self) -> list[T_PageSearch]:
        return [
            {
                "title": self._parse_title(el),
                "thumbnail": self._parse_thumbnail(el),
                "url": self._parse_url(el),
            }
            for el in self._split_doc(self._document)
        ]


class PageAnime:
    """Anime page information. anime path contains in SearchView.url or Ongoing.url

    - id needed for next API requests
    - raw_json used for extract extra metadata (unescape required)

    USAGE:

        GET https://animego.one/anime/<ANIME_PATH>

    EXAMPLE:

        GET https://animego.one/anime/eksperimenty-leyn-1114


    ISSUES:
        If blocked, you can try skip extract anime metadata and send api request:

        id contains in url:
            - id=1114 for https://animego.one/anime/eksperimenty-leyn-1114
            - id=2589 for https://animego.org/anime/chelovek-muskul-2589

        GET 'https://animego.one/anime/{id}/player?_allow=true'


    {
        "title": "String",
        "description": "String",
        "thumbnail": "String",
        "id": "String",
        "raw_json": {
            "context": "String",
            "type": "String",
            "url": "String",
            "name": "String",
            "alternateName": "String",
            "image": "String",
            "description": "String",
            "genre": "Array<String>",
            "contentRating": "String",
            "datePublished": "String",
            "keywords": "String",
            "creator": [
                {
                    "type": "String",
                    "name": "String"
                },
                "..."
            ],
            "aggregateRating": {
                "type": "String",
                "ratingCount": "Int",
                "bestRating": "Int",
                "ratingValue": "String"
            },
            "numberOfEpisodes": "Int"
        }
    }"""

    def __init__(self, document: Union[str, html.HtmlElement]) -> None:
        if isinstance(document, html.HtmlElement):
            self._document = document
        elif isinstance(document, str):
            self._document = html.fromstring(document.strip() or FALLBACK_HTML_STR)

    def _parse_title(self, v: html.HtmlElement) -> str:
        v0 = v.cssselect(".entity__title h1")[0]

        return v0.text_content()

    def _parse_description(self, v: html.HtmlElement) -> str:
        v0 = v
        with suppress(Exception):
            v1 = v0.cssselect(".description")
            v2 = [e.text_content() for e in v1]
            v3 = "".join(v2)

            return re.sub("(?:^\\s+)|(?:\\s+$)", "", v3)
        return ""

    def _parse_thumbnail(self, v: html.HtmlElement) -> str:
        v0 = v.cssselect(".d-sm-flex .image__picture img.image__img")[0]

        return v0.get("src")

    def _parse_id(self, v: html.HtmlElement) -> str:
        v0 = v.cssselect('link[rel="canonical"]')[0]
        v1 = v0.get("href")

        return re.search("-(.?\\d{2,})", v1)[1]

    def _parse_raw_json(self, v: html.HtmlElement) -> J_Content:
        v0 = v.cssselect("script[type='application/ld+json']")[0]
        v1 = v0.text_content()
        v2 = v1.replace('"@type"', '"type"')
        v3 = v2.replace('"@context"', '"context"')

        return json.loads(v3)

    def parse(self) -> T_PageAnime:
        return {
            "title": self._parse_title(self._document),
            "description": self._parse_description(self._document),
            "thumbnail": self._parse_thumbnail(self._document),
            "id": self._parse_id(self._document),
            "raw_json": self._parse_raw_json(self._document),
        }


class Episodes:
    """episodes signature example (exclude in film)
    ```
    <div class="scroll-snap-slider d-none d-lg-flex">
        <div class="scroll-snap-slide player-video-bar__item user-select-none px-1"
            data-episode-number="1" data-episode-type="1"
            data-episode-title="Elaina, the Apprentice Witch" data-episode-released="2 октября 2020"
            data-episode-description="" data-episode="21516">
            ...
    ```


    [
        {
            "num": "Int",
            "title": "String",
            "type": "String",
            "released": "String",
            "id": "String"
        },
        "..."
    ]"""

    def __init__(self, document: Union[str, html.HtmlElement]) -> None:
        if isinstance(document, html.HtmlElement):
            self._document = document
        elif isinstance(document, str):
            self._document = html.fromstring(document.strip() or FALLBACK_HTML_STR)

    def _split_doc(self, v: html.HtmlElement) -> list[html.HtmlElement]:
        return v.cssselect(".player-video-bar__item")

    def _parse_num(self, v: html.HtmlElement) -> int:
        v0 = v.get("data-episode-number")
        v1 = re.sub("[^\\d+]", "", v0)

        return int(v1)

    def _parse_title(self, v: html.HtmlElement) -> str:
        return v.get("data-episode-title")

    def _parse_type(self, v: html.HtmlElement) -> str:
        return v.get("data-episode-type")

    def _parse_released(self, v: html.HtmlElement) -> str:
        return v.get("data-episode-released")

    def _parse_id(self, v: html.HtmlElement) -> str:
        return v.get("data-episode")

    def parse(self) -> list[T_Episodes]:
        return [
            {
                "num": self._parse_num(el),
                "title": self._parse_title(el),
                "type": self._parse_type(el),
                "released": self._parse_released(el),
                "id": self._parse_id(el),
            }
            for el in self._split_doc(self._document)
        ]


class Dubbers:
    """dubbers signature:

    ```
    <div class="list-group pt-2 position-absolute w-100">
        <button class="align-items-center d-flex gap-2 list-group-item list-group-item-action mb-1"
                role="button" data-translation="2"><span class="text-truncate">AniLibria</span> <span
                class="error__player d-none text-danger small text-nowrap">(ошибка)</span>
        </button>
    ...
    ```



    {
        "<k>": "String",
        "<k_N>": "..."
    }"""

    def __init__(self, document: Union[str, html.HtmlElement]) -> None:
        if isinstance(document, html.HtmlElement):
            self._document = document
        elif isinstance(document, str):
            self._document = html.fromstring(document.strip() or FALLBACK_HTML_STR)

    def _split_doc(self, v: html.HtmlElement) -> list[html.HtmlElement]:
        return v.cssselect("button[data-translation]")

    def _parse_key(self, v: html.HtmlElement) -> str:
        return v.get("data-translation")

    def _parse_value(self, v: html.HtmlElement) -> str:
        v0 = v.cssselect("span")[0]
        v1 = v0.text_content()

        return v1.strip(" ")

    def parse(self) -> T_Dubbers:
        return {self._parse_key(el): self._parse_value(el) for el in self._split_doc(self._document)}


class PageEpisode:
    """Representation episodes

    NOTE:
        film pages does not exist select[name="series"] element.

    Prepare:
      1. get id from Anime object
      2. GET 'https://animego.me/player/{Anime.id}'
      3. extract html from json by ['data']['content'] key
      4. OPTIONAL: unescape HTML

    EXAMPLE:
        GET https://animego.me/player/1114


    {
        "is_film": "Bool",
        "episodes": [
            {
                "num": "Int",
                "title": "String",
                "type": "String",
                "released": "String",
                "id": "String"
            },
            "..."
        ],
        "dubbers": {
            "<k>": "String",
            "<k_N>": "..."
        }
    }"""

    def __init__(self, document: Union[str, html.HtmlElement]) -> None:
        if isinstance(document, html.HtmlElement):
            self._document = document
        elif isinstance(document, str):
            self._document = html.fromstring(document.strip() or FALLBACK_HTML_STR)

    def _parse_is_film(self, v: html.HtmlElement) -> bool:
        v0 = v
        with suppress(Exception):
            assert not v0.cssselect('select[name="series"]'), ""
            v1 = v0

            return bool(v1 or v1 == 0)
        return True

    def _parse_episodes(self, v: html.HtmlElement) -> list[T_Episodes]:
        return Episodes(v).parse()

    def _parse_dubbers(self, v: html.HtmlElement) -> T_Dubbers:
        return Dubbers(v).parse()

    def parse(self) -> T_PageEpisode:
        return {
            "is_film": self._parse_is_film(self._document),
            "episodes": self._parse_episodes(self._document),
            "dubbers": self._parse_dubbers(self._document),
        }


class EpisodeVideos:
    """

    signature:

    ```
     <button data-player="//aniboom.one/embed/z68qn1VdNvg?translation=2" data-provider="24"
            data-ptranslation="2" data-provider-title="AniBoom" data-translation-title="AniLibria"
            class="align-items-center d-flex gap-2 list-group-item list-group-item-action mb-1"
            role="button"><span class="text-truncate">AniBoom</span> <span
                class="error__player d-none text-danger small text-nowrap">(ошибка)</span></button>

    ...
    ```



    [
        {
            "player": "String",
            "data_provider": "String",
            "data_provide_dubbing": "String"
        },
        "..."
    ]"""

    def __init__(self, document: Union[str, html.HtmlElement]) -> None:
        if isinstance(document, html.HtmlElement):
            self._document = document
        elif isinstance(document, str):
            self._document = html.fromstring(document.strip() or FALLBACK_HTML_STR)

    def _split_doc(self, v: html.HtmlElement) -> list[html.HtmlElement]:
        return v.cssselect("button[data-player]")

    def _parse_player(self, v: html.HtmlElement) -> str:
        v0 = v.get("data-player")
        v1 = re.sub("^https?", "", v0)

        return f"https:{v1}"

    def _parse_data_provider(self, v: html.HtmlElement) -> str:
        return v.get("data-provider")

    def _parse_data_provide_dubbing(self, v: html.HtmlElement) -> str:
        v0 = v.get("data-ptranslation")

        return re.sub("(?:^\\s+)|(?:\\s+$)", "", v0)

    def parse(self) -> list[T_EpisodeVideos]:
        return [
            {
                "player": self._parse_player(el),
                "data_provider": self._parse_data_provider(el),
                "data_provide_dubbing": self._parse_data_provide_dubbing(el),
            }
            for el in self._split_doc(self._document)
        ]


class PageEpisodeVideo:
    """Represent Episode object for film (it have not same signatures)

    NOTE:
        film pages does not exist CSS selector `.player-video-bar__item` or `select[name="series"]`

    Prepare:
      1. get id from Anime object
      2. GET 'https://animego.one/player/{Anime.id}'
      3. extract html from json by ['data']['content'] key
      4. OPTIONAL: unescape HTML

    EXAMPLE:
        GET https://animego.one/player/315


    {
        "is_film": "Bool",
        "dubbers": {
            "<k>": "String",
            "<k_N>": "..."
        },
        "videos": [
            {
                "player": "String",
                "data_provider": "String",
                "data_provide_dubbing": "String"
            },
            "..."
        ]
    }"""

    def __init__(self, document: Union[str, html.HtmlElement]) -> None:
        if isinstance(document, html.HtmlElement):
            self._document = document
        elif isinstance(document, str):
            self._document = html.fromstring(document.strip() or FALLBACK_HTML_STR)

    def _parse_is_film(self, v: html.HtmlElement) -> bool:
        v0 = v
        with suppress(Exception):
            assert not v0.cssselect('select[name="series"]'), ""
            v1 = v0

            return bool(v1 or v1 == 0)
        return True

    def _parse_dubbers(self, v: html.HtmlElement) -> T_Dubbers:
        return Dubbers(v).parse()

    def _parse_videos(self, v: html.HtmlElement) -> list[T_EpisodeVideos]:
        return EpisodeVideos(v).parse()

    def parse(self) -> T_PageEpisodeVideo:
        return {
            "is_film": self._parse_is_film(self._document),
            "dubbers": self._parse_dubbers(self._document),
            "videos": self._parse_videos(self._document),
        }


class SourceVideoView:
    """Signature:

    ```
     <button data-player="//animego.me/cdn-iframe/40571/AnilibriaTV/1/2" data-provider="26"
            data-ptranslation="2" data-provider-title="CVH" data-translation-title="AniLibria"
            class="align-items-center d-flex gap-2 list-group-item list-group-item-action mb-1"
            role="button"><span class="text-truncate">CVH</span> <span
                class="error__player d-none text-danger small text-nowrap">(ошибка)</span></button>
    ```



    [
        {
            "title": "String",
            "url": "String",
            "data_provider": "String",
            "data_provide_dubbing": "String",
            "data_translation_title": "String"
        },
        "..."
    ]"""

    def __init__(self, document: Union[str, html.HtmlElement]) -> None:
        if isinstance(document, html.HtmlElement):
            self._document = document
        elif isinstance(document, str):
            self._document = html.fromstring(document.strip() or FALLBACK_HTML_STR)

    def _split_doc(self, v: html.HtmlElement) -> list[html.HtmlElement]:
        return v.cssselect("button[data-player]")

    def _parse_title(self, v: html.HtmlElement) -> str:
        v0 = v.cssselect("span")[0]

        return v0.text_content()

    def _parse_url(self, v: html.HtmlElement) -> str:
        v0 = v.get("data-player")

        return f"https:{v0}"

    def _parse_data_provider(self, v: html.HtmlElement) -> str:
        return v.get("data-provider")

    def _parse_data_provide_dubbing(self, v: html.HtmlElement) -> str:
        return v.get("data-ptranslation")

    def _parse_data_translation_title(self, v: html.HtmlElement) -> str:
        return v.get("data-translation-title")

    def parse(self) -> list[T_SourceVideoView]:
        return [
            {
                "title": self._parse_title(el),
                "url": self._parse_url(el),
                "data_provider": self._parse_data_provider(el),
                "data_provide_dubbing": self._parse_data_provide_dubbing(el),
                "data_translation_title": self._parse_data_translation_title(el),
            }
            for el in self._split_doc(self._document)
        ]


class PageSource:
    """representation player urls (episodes only)

    Prepare:
      1. get num and id from Episode

      2.

      GET https://animego.me/player/videos/{Episode.id}

      3. extract html from json by ["data"]["content"] key

      4. OPTIONAL: unescape document

    EXAMPLE:

        GET https://animego.one/anime/series?dubbing=2&provider=24&episode=2&id=15837


    {
        "dubbers": {
            "<k>": "String",
            "<k_N>": "..."
        },
        "videos": [
            {
                "title": "String",
                "url": "String",
                "data_provider": "String",
                "data_provide_dubbing": "String",
                "data_translation_title": "String"
            },
            "..."
        ]
    }"""

    def __init__(self, document: Union[str, html.HtmlElement]) -> None:
        if isinstance(document, html.HtmlElement):
            self._document = document
        elif isinstance(document, str):
            self._document = html.fromstring(document.strip() or FALLBACK_HTML_STR)

    def _parse_dubbers(self, v: html.HtmlElement) -> T_Dubbers:
        return Dubbers(v).parse()

    def _parse_videos(self, v: html.HtmlElement) -> list[T_SourceVideoView]:
        return SourceVideoView(v).parse()

    def parse(self) -> T_PageSource:
        return {
            "dubbers": self._parse_dubbers(self._document),
            "videos": self._parse_videos(self._document),
        }
